<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked List Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <style>
        .linkedlist-visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            min-height: 120px;
            flex-wrap: wrap;
            gap: 10px;
            overflow-x: auto;
            padding: 20px 0;
        }

        .node-container {
            display: flex;
            align-items: center;
            margin: 5px;
        }

        .node-box {
            width: 80px;
            height: 60px;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            background-color: #e0e0e0;
            border-radius: 5px;
            transition: all 0.3s ease;
            position: relative;
        }

        .node-box.highlight {
            background-color: #4CAF50;
            color: white;
            transform: scale(1.1);
        }

        .node-box.traversing {
            background-color: #2196F3;
            color: white;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .arrow {
            font-size: 24px;
            color: #333;
            margin: 0 10px;
            font-weight: bold;
        }

        .null-terminator {
            font-size: 18px;
            color: #666;
            font-weight: bold;
            font-style: italic;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .empty-list {
            color: #999;
            font-style: italic;
            font-size: 18px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }

            .control-group {
                flex-direction: column;
                text-align: center;
                gap: 10px;
                width: 100%;
                max-width: 250px;
            }

            .linkedlist-visualization {
                justify-content: flex-start;
                overflow-x: auto;
                padding: 20px 10px;
            }

            .node-box {
                width: 70px;
                height: 50px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .linkedlist-visualization {
                flex-direction: column;
                align-items: center;
                overflow-x: visible;
            }

            .node-container {
                flex-direction: column;
                margin: 10px 0;
            }

            .arrow {
                transform: rotate(90deg);
                margin: 5px 0;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Linked List Visualizer</h1>
        <p>Visualize linked list operations: Insert at Head, Delete Node, and Traverse</p>
    </div>

    <div class="navigation">
        <a href="index.html" class="nav-link">← Back to Menu</a>
    </div>

    <div class="linkedlist-container">
        <h3>Linked List Visualization</h3>
        <div class="linkedlist-visualization" id="linkedlistVisualization">
            <!-- Linked list nodes will be displayed here -->
        </div>

        <div class="controls">
            <div class="control-group">
                <input type="number" id="insertValue" placeholder="Value" min="0" max="999">
                <button class="btn-success" onclick="insertAtHead()">Insert at Head</button>
            </div>

            <div class="control-group">
                <input type="number" id="deleteValue" placeholder="Value" min="0" max="999">
                <button class="btn-danger" onclick="deleteNode()">Delete Node</button>
            </div>

            <div class="control-group">
                <button class="btn-info" onclick="traverseList()">Traverse List</button>
            </div>

            <div class="control-group">
                <button class="btn-primary" onclick="clearHighlight()">Clear Highlight</button>
            </div>
        </div>

        <div class="result-display" id="resultDisplay">
            Ready to perform linked list operations. Current list: 10 -> 20 -> 30 -> NULL
        </div>
    </div>

    <script>
        /*
            EDUCATIONAL NOTE: Linked List Data Structure Implementation
            
            This JavaScript implementation simulates the C++ linked list from code.cpp:
            - C++ struct Node { int data; Node* next; } → JavaScript { data: value, next: index }
            - C++ pointers → JavaScript array indices (simplified for visualization)
            - C++ dynamic allocation → JavaScript object creation
            
            Key Linked List Concepts Demonstrated:
            1. Node structure with data and pointer to next node
            2. Dynamic size - can grow/shrink during runtime
            3. Sequential access - must traverse from head to reach any node
            4. Pointer manipulation for insertions and deletions
            5. NULL termination - last node points to null
            
            Note: This implementation uses array indices instead of actual pointers
            for simplicity and visualization purposes.
        */

        // Initialize linked list with sample data matching code.cpp
        let listNodes = [
            { data: 10, next: 1 },  // Head node points to index 1
            { data: 20, next: 2 },  // Second node points to index 2
            { data: 30, next: null } // Tail node points to null
        ];
        let traversalInProgress = false;

        // Initialize display
        updateDisplay();
        showResult("Ready to perform linked list operations. Current list: " + getListString(), "info");

        function updateDisplay() {
            const container = document.getElementById('linkedlistVisualization');
            container.innerHTML = '';

            if (listNodes.length === 0) {
                container.innerHTML = '<div class="empty-list">NULL (Empty List)</div>';
                return;
            }

            // Start from head (index 0)
            let currentIndex = 0;
            let nodeCount = 0;

            while (currentIndex !== null && nodeCount < listNodes.length) {
                const node = listNodes[currentIndex];

                // Create node container
                const nodeContainer = document.createElement('div');
                nodeContainer.className = 'node-container';

                // Create node box
                const nodeBox = document.createElement('div');
                nodeBox.className = 'node-box';
                nodeBox.id = `node-${currentIndex}`;
                nodeBox.textContent = node.data;
                nodeContainer.appendChild(nodeBox);

                // Add arrow if not the last node
                if (node.next !== null) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.textContent = '→';
                    nodeContainer.appendChild(arrow);
                }

                container.appendChild(nodeContainer);

                currentIndex = node.next;
                nodeCount++;
            }

            // Add NULL terminator
            const nullContainer = document.createElement('div');
            nullContainer.className = 'node-container';
            const nullTerminator = document.createElement('div');
            nullTerminator.className = 'null-terminator';
            nullTerminator.textContent = 'NULL';
            nullContainer.appendChild(nullTerminator);
            container.appendChild(nullContainer);
        }

        /*
            EDUCATIONAL NOTE: Insert at Head Operation
            
            Inserting at the head of a linked list:
            1. Create a new node with the given data
            2. Set new node's next pointer to current head
            3. Update head pointer to point to new node
            
            This operation is O(1) time complexity - constant time regardless of list size.
            In C++: Node* newNode = new Node(value); newNode->next = head; head = newNode;
            
            Real-world analogy: Adding a new car to the front of a train
        */
        function insertAtHead() {
            const input = document.getElementById('insertValue');
            const value = parseInt(input.value);

            // Input validation
            if (isNaN(value)) {
                showResult("Error: Please enter a valid number", "error");
                return;
            }

            // Create new node that will become the new head
            const newNode = { data: value, next: listNodes.length > 0 ? 0 : null };

            // Update existing nodes' indices (shift them by 1)
            listNodes = listNodes.map((node, index) => ({
                ...node,
                next: node.next !== null ? node.next + 1 : null
            }));

            // Insert new node at the beginning (becomes new head)
            listNodes.unshift(newNode);

            updateDisplay();
            showResult("Successfully inserted " + value + " at head. New list: " + getListString(), "success");

            // Clear input field
            input.value = '';
        }

        function deleteNode() {
            const input = document.getElementById('deleteValue');
            const value = parseInt(input.value);

            if (isNaN(value)) {
                showResult("Error: Please enter a valid number", "error");
                return;
            }

            if (listNodes.length === 0) {
                showResult("Error: List is empty", "error");
                return;
            }

            // Find the node to delete
            let nodeToDeleteIndex = -1;
            for (let i = 0; i < listNodes.length; i++) {
                if (listNodes[i].data === value) {
                    nodeToDeleteIndex = i;
                    break;
                }
            }

            if (nodeToDeleteIndex === -1) {
                showResult("Error: Node with value " + value + " not found in the list", "error");
                return;
            }

            // If deleting the head node
            if (nodeToDeleteIndex === 0) {
                const nextIndex = listNodes[0].next;
                listNodes.splice(0, 1);

                // Update all next pointers
                listNodes = listNodes.map(node => ({
                    ...node,
                    next: node.next !== null && node.next > 0 ? node.next - 1 : node.next
                }));
            } else {
                // Find the previous node
                let prevIndex = -1;
                for (let i = 0; i < listNodes.length; i++) {
                    if (listNodes[i].next === nodeToDeleteIndex) {
                        prevIndex = i;
                        break;
                    }
                }

                if (prevIndex !== -1) {
                    // Update previous node's next pointer
                    listNodes[prevIndex].next = listNodes[nodeToDeleteIndex].next;
                }

                // Remove the node
                listNodes.splice(nodeToDeleteIndex, 1);

                // Update all next pointers that point to indices after the deleted node
                listNodes = listNodes.map(node => ({
                    ...node,
                    next: node.next !== null && node.next > nodeToDeleteIndex ? node.next - 1 : node.next
                }));
            }

            updateDisplay();
            showResult("Successfully deleted node with value " + value + ". New list: " + getListString(), "success");

            // Clear input
            input.value = '';
        }

        /*
            EDUCATIONAL NOTE: Linked List Traversal
            
            Traversing a linked list requires following the next pointers:
            1. Start at the head node
            2. Visit current node (process its data)
            3. Follow the next pointer to the next node
            4. Repeat until reaching NULL (end of list)
            
            Time Complexity: O(n) - must visit each node sequentially
            Space Complexity: O(1) - only need one pointer to track current position
            
            This demonstrates why linked lists don't support random access like arrays.
            Real-world analogy: Following a treasure hunt with clues leading to the next location
        */
        async function traverseList() {
            // Check for empty list
            if (listNodes.length === 0) {
                showResult("Error: List is empty - nothing to traverse", "error");
                return;
            }

            // Prevent multiple simultaneous traversals
            if (traversalInProgress) {
                showResult("Traversal already in progress", "error");
                return;
            }

            traversalInProgress = true;
            clearHighlight();

            let traversalPath = [];
            let currentIndex = 0; // Start at head (index 0)
            let nodeCount = 0;    // Safety counter to prevent infinite loops

            showResult("Starting traversal...", "info");

            // Follow the next pointers until reaching NULL
            while (currentIndex !== null && nodeCount < listNodes.length) {
                const node = listNodes[currentIndex];
                traversalPath.push(node.data);

                // Highlight current node being visited
                const nodeElement = document.getElementById(`node-${currentIndex}`);
                if (nodeElement) {
                    nodeElement.classList.add('traversing');
                }

                // Wait for animation to show traversal progress
                await new Promise(resolve => setTimeout(resolve, 800));

                // Mark node as visited
                if (nodeElement) {
                    nodeElement.classList.remove('traversing');
                    nodeElement.classList.add('highlight');
                }

                // Move to next node
                currentIndex = node.next;
                nodeCount++;
            }

            showResult("Traversal complete! Path: " + traversalPath.join(" -> ") + " -> NULL", "success");
            traversalInProgress = false;
        }

        function clearHighlight() {
            const highlightedElements = document.querySelectorAll('.node-box.highlight, .node-box.traversing');
            highlightedElements.forEach(element => {
                element.classList.remove('highlight', 'traversing');
            });
            showResult("Highlight cleared. Current list: " + getListString(), "info");
        }

        function getListString() {
            if (listNodes.length === 0) {
                return "NULL (Empty List)";
            }

            let result = [];
            let currentIndex = 0;
            let nodeCount = 0;

            while (currentIndex !== null && nodeCount < listNodes.length) {
                result.push(listNodes[currentIndex].data);
                currentIndex = listNodes[currentIndex].next;
                nodeCount++;
            }

            return result.join(" -> ") + " -> NULL";
        }

        function showResult(message, type = "info") {
            const resultDiv = document.getElementById('resultDisplay');
            resultDiv.textContent = message;

            // Remove all type classes
            resultDiv.classList.remove('success', 'error', 'info');

            // Add the appropriate type class
            if (type) {
                resultDiv.classList.add(type);
            }
        }

        // Handle Enter key for inputs
        document.getElementById('insertValue').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                insertAtHead();
            }
        });

        document.getElementById('deleteValue').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                deleteNode();
            }
        });
    </script>
</body>

</html>