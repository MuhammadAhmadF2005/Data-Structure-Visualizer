<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f4f8;
            /* Light blue-gray background */
            color: #333;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            /* Darker blue */
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: #7f8c8d;
            /* Grayish text */
            font-size: 16px;
        }

        .navigation {
            text-align: center;
            margin-bottom: 30px;
        }

        .nav-link {
            display: inline-block;
            padding: 10px 20px;
            background-color: #3498db;
            /* Bright blue */
            color: white;
            text-decoration: none;
            border-radius: 8px;
            margin: 0 10px;
            transition: background-color 0.3s ease;
            font-weight: 600;
        }

        .nav-link:hover,
        .nav-link:focus {
            background-color: #2980b9;
            /* Darker blue on hover */
        }

        .nav-link:active {
            background-color: #1f618d;
        }

        .tree-container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            margin-bottom: 30px;
        }

        .tree-visualization {
            position: relative;
            width: 100%;
            height: 450px;
            margin: 30px 0;
            overflow: visible;
        }

        .tree-node {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid #bdc3c7;
            /* Softer border */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            background-color: #ecf0f1;
            /* Light gray background */
            color: #2c3e50;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .tree-node.highlight {
            background-color: #e67e22;
            /* Orange for highlight */
            color: white;
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(230, 126, 34, 0.7);
            border-color: #d35400;
        }

        .tree-node.visited {
            background-color: #9b59b6;
            /* Amethyst for visited */
            color: white;
            border-color: #8e44ad;
        }

        /* Positioning nodes in tree structure */
        #node-1 {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #node-2 {
            top: 120px;
            left: 25%;
            transform: translateX(-50%);
        }

        #node-3 {
            top: 120px;
            left: 75%;
            transform: translateX(-50%);
        }

        #node-4 {
            top: 220px;
            left: 12.5%;
            transform: translateX(-50%);
        }

        #node-5 {
            top: 220px;
            left: 37.5%;
            transform: translateX(-50%);
        }

        #node-6 {
            top: 220px;
            left: 62.5%;
            transform: translateX(-50%);
        }

        #node-7 {
            top: 220px;
            left: 87.5%;
            transform: translateX(-50%);
        }

        /* Dynamic connection lines */
        .tree-line {
            position: absolute;
            background-color: #95a5a6;
            /* Gray for lines */
            height: 2px;
            /* All lines have a consistent thickness */
            transform-origin: 0 0;
            /* Rotate lines from their starting point */
            z-index: 1;
        }

        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 30px 0;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            /* Rounded corners */
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        button:active {
            transform: scale(0.98);
            box-shadow: none;
        }

        .btn-primary {
            background-color: #3498db;
            /* Bright Blue */
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-success {
            background-color: #2ecc71;
            /* Emerald Green */
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-info {
            background-color: #1abc9c;
            /* Turquoise */
            color: white;
        }

        .btn-info:hover {
            background-color: #16a085;
        }

        .btn-warning {
            background-color: #f1c40f;
            /* Sunflower Yellow */
            color: #2c3e50;
        }

        .btn-warning:hover {
            background-color: #f39c12;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .result-display {
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            min-height: 50px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            color: #2c3e50;
        }

        .result-display.success {
            background-color: #dff0d8;
            border-color: #d6e9c6;
            color: #3c763d;
        }

        .result-display.info {
            background-color: #d9edf7;
            border-color: #bce8f1;
            color: #31708f;
        }

        .traversal-sequence {
            font-size: 18px;
            font-weight: 600;
            margin-top: 10px;
            padding: 12px;
            background-color: #fdf5e6;
            /* Lighter orange */
            border: 1px solid #fbe2b1;
            border-radius: 8px;
            color: #c09853;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .header p {
                font-size: 14px;
            }

            .tree-container {
                padding: 20px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            button {
                padding: 12px 24px;
                font-size: 18px;
                min-height: 48px;
                width: 100%;
                max-width: 250px;
            }

            .tree-node {
                width: 40px;
                height: 40px;
                font-size: 16px;
                margin: 0 15px;
            }

            .tree-visualization {
                height: 350px;
            }

            .tree-node {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            /* Adjust line lengths for smaller screens */
            .line-1-to-2,
            .line-1-to-3,
            .line-2-to-4,
            .line-2-to-5,
            .line-3-to-6,
            .line-3-to-7 {
                height: 70px;
            }

            .line-2-to-4,
            .line-2-to-5 {
                top: 160px;
            }

            .line-3-to-6,
            .line-3-to-7 {
                top: 160px;
            }

            #node-4,
            #node-5,
            #node-6,
            #node-7 {
                top: 210px;
            }

            .nav-link {
                padding: 12px 24px;
                font-size: 16px;
                min-height: 48px;
            }
        }

        @media (max-width: 480px) {
            .tree-visualization {
                height: 300px;
            }

            .tree-node {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }

            /* Further adjust line lengths for very small screens */
            .line-1-to-2,
            .line-1-to-3,
            .line-2-to-4,
            .line-2-to-5,
            .line-3-to-6,
            .line-3-to-7 {
                height: 60px;
            }

            .line-2-to-4,
            .line-2-to-5 {
                top: 150px;
            }

            .line-3-to-6,
            .line-3-to-7 {
                top: 150px;
            }

            #node-2,
            #node-3 {
                top: 110px;
            }

            #node-4,
            #node-5,
            #node-6,
            #node-7 {
                top: 190px;
            }

            .tree-level {
                margin: 30px 0;
            }

            .tree-visualization {
                min-height: 250px;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Binary Tree Visualizer</h1>
        <p>Visualize binary tree traversals: Preorder, Inorder, and Postorder</p>
    </div>

    <div class="navigation">
        <a href="index.html" class="nav-link">← Back to Menu</a>
    </div>

    <div class="tree-container">
        <h3>Binary Tree Visualization</h3>
        <!-- 
            EDUCATIONAL NOTE: Binary Tree Structure
            
            This tree matches the structure from code.cpp:
                    1
                   / \
                  2   3
                 / \ / \
                4 5 6 7
            
            The tree uses absolute positioning for precise node placement
            and dedicated div elements for connecting lines. Each line is
            carefully positioned and rotated to connect parent to child nodes.
        -->
        <div class="tree-visualization" id="treeVisualization">
            <!-- Connection lines (drawn first, behind nodes) -->
            <div class="tree-line" id="line-1-to-2"></div>
            <div class="tree-line" id="line-1-to-3"></div>
            <div class="tree-line" id="line-2-to-4"></div>
            <div class="tree-line" id="line-2-to-5"></div>
            <div class="tree-line" id="line-3-to-6"></div>
            <div class="tree-line" id="line-3-to-7"></div>

            <!-- Tree nodes positioned absolutely -->
            <div class="tree-node" id="node-1" data-value="1">1</div>
            <div class="tree-node" id="node-2" data-value="2">2</div>
            <div class="tree-node" id="node-3" data-value="3">3</div>
            <div class="tree-node" id="node-4" data-value="4">4</div>
            <div class="tree-node" id="node-5" data-value="5">5</div>
            <div class="tree-node" id="node-6" data-value="6">6</div>
            <div class="tree-node" id="node-7" data-value="7">7</div>
        </div>

        <div class="controls">
            <div style="margin-bottom: 15px;">
                <input type="number" id="nodeValue" placeholder="Node value" min="1" max="99"
                    style="padding: 8px; margin-right: 10px; border: 2px solid #ddd; border-radius: 5px;">
                <button class="btn-success" onclick="addNode()">Add Node</button>
                <button class="btn-danger" onclick="deleteNode()">Delete Node</button>
            </div>

            <div>
                <button class="btn-primary" onclick="preorderTraversal()">Preorder Traversal</button>
                <button class="btn-success" onclick="inorderTraversal()">Inorder Traversal</button>
                <button class="btn-info" onclick="postorderTraversal()">Postorder Traversal</button>
                <button class="btn-warning" onclick="resetTree()">Reset Tree</button>
            </div>
        </div>

        <div class="result-display" id="resultDisplay">
            Ready to perform tree traversals. Tree structure: Root(1) → Left(2,4,5) → Right(3,6,7)
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Draw lines on initial load
            updateTreeLines();

            // Redraw lines on window resize
            window.addEventListener('resize', updateTreeLines);
        });

        // Tree data structure matching code.cpp
        const treeData = {
            data: 1,
            left: {
                data: 2,
                left: { data: 4, left: null, right: null },
                right: { data: 5, left: null, right: null }
            },
            right: {
                data: 3,
                left: { data: 6, left: null, right: null },
                right: { data: 7, left: null, right: null }
            }
        };

        let isTraversing = false;
        let currentTraversal = [];

        // Initialize display
        showResult("Ready to perform tree traversals. Tree structure: Root(1) → Left(2,4,5) → Right(3,6,7)", "info");

        /*
            EDUCATIONAL NOTE: Preorder Traversal
            
            Preorder traversal visits nodes in Root → Left → Right order:
            1. Process the current node first
            2. Recursively traverse the left subtree
            3. Recursively traverse the right subtree
            
            This matches the C++ preorder function from code.cpp.
            Use case: Creating a copy of the tree, prefix expression evaluation
            Expected sequence for our tree: 1 → 2 → 4 → 5 → 3 → 6 → 7
        */
        async function preorderTraversal() {
            if (isTraversing) return; // Prevent multiple traversals

            resetTree();
            isTraversing = true;
            currentTraversal = [];

            showResult("Starting Preorder Traversal (Root → Left → Right)...", "info");

            await preorderHelper(treeData);

            showResult("Preorder Traversal Complete!", "success");
            displayTraversalSequence("Preorder", currentTraversal);
            isTraversing = false;
        }

        async function preorderHelper(node) {
            if (!node) return;

            // Visit current node
            await highlightNode(node.data);
            currentTraversal.push(node.data);

            // Traverse left subtree
            await preorderHelper(node.left);

            // Traverse right subtree
            await preorderHelper(node.right);
        }

        /*
            EDUCATIONAL NOTE: Inorder Traversal
            
            Inorder traversal visits nodes in Left → Root → Right order:
            1. Recursively traverse the left subtree
            2. Process the current node
            3. Recursively traverse the right subtree
            
            This matches the C++ inorder function from code.cpp.
            Use case: Binary Search Trees (gives sorted order), infix expression evaluation
            Expected sequence for our tree: 4 → 2 → 5 → 1 → 6 → 3 → 7
        */
        async function inorderTraversal() {
            if (isTraversing) return; // Prevent multiple traversals

            resetTree();
            isTraversing = true;
            currentTraversal = [];

            showResult("Starting Inorder Traversal (Left → Root → Right)...", "info");

            await inorderHelper(treeData);

            showResult("Inorder Traversal Complete!", "success");
            displayTraversalSequence("Inorder", currentTraversal);
            isTraversing = false;
        }

        async function inorderHelper(node) {
            if (!node) return;

            // Traverse left subtree
            await inorderHelper(node.left);

            // Visit current node
            await highlightNode(node.data);
            currentTraversal.push(node.data);

            // Traverse right subtree
            await inorderHelper(node.right);
        }

        /*
            EDUCATIONAL NOTE: Postorder Traversal
            
            Postorder traversal visits nodes in Left → Right → Root order:
            1. Recursively traverse the left subtree
            2. Recursively traverse the right subtree  
            3. Process the current node last
            
            This matches the C++ postorder function from code.cpp.
            Use case: Deleting trees (delete children before parent), postfix expression evaluation
            Expected sequence for our tree: 4 → 5 → 2 → 6 → 7 → 3 → 1
        */
        async function postorderTraversal() {
            if (isTraversing) return; // Prevent multiple traversals

            resetTree();
            isTraversing = true;
            currentTraversal = [];

            showResult("Starting Postorder Traversal (Left → Right → Root)...", "info");

            await postorderHelper(treeData);

            showResult("Postorder Traversal Complete!", "success");
            displayTraversalSequence("Postorder", currentTraversal);
            isTraversing = false;
        }

        async function postorderHelper(node) {
            if (!node) return;

            // Traverse left subtree
            await postorderHelper(node.left);

            // Traverse right subtree
            await postorderHelper(node.right);

            // Visit current node
            await highlightNode(node.data);
            currentTraversal.push(node.data);
        }

        async function highlightNode(value) {
            const nodeElement = document.getElementById(`node-${value}`);
            if (nodeElement) {
                // Highlight current node
                nodeElement.classList.add('highlight');

                // Wait for animation
                await sleep(800);

                // Mark as visited
                nodeElement.classList.remove('highlight');
                nodeElement.classList.add('visited');

                // Brief pause before next node
                await sleep(200);
            }
        }

        function addNode() {
            const input = document.getElementById('nodeValue');
            const value = parseInt(input.value);

            if (isNaN(value)) {
                showResult("Please enter a valid number for the node value.", "error");
                return;
            }

            if (isTraversing) {
                showResult("Cannot modify tree during traversal.", "error");
                return;
            }

            // Add node to tree data structure
            insertNodeInTree(treeData, value);

            // Rebuild and redraw the tree
            rebuildTreeVisualization();

            showResult(`Added node ${value} to the tree.`, "success");
            input.value = '';
        }

        function deleteNode() {
            const input = document.getElementById('nodeValue');
            const value = parseInt(input.value);

            if (isNaN(value)) {
                showResult("Please enter a valid number for the node to delete.", "error");
                return;
            }

            if (isTraversing) {
                showResult("Cannot modify tree during traversal.", "error");
                return;
            }

            // Delete node from tree data structure
            const deleted = deleteNodeFromTree(treeData, value);

            if (deleted) {
                // Rebuild and redraw the tree
                rebuildTreeVisualization();
                showResult(`Deleted node ${value} from the tree.`, "success");
            } else {
                showResult(`Node ${value} not found in the tree.`, "error");
            }

            input.value = '';
        }

        function insertNodeInTree(node, value) {
            if (!node) {
                return { data: value, left: null, right: null };
            }

            if (value < node.data) {
                node.left = insertNodeInTree(node.left, value);
            } else if (value > node.data) {
                node.right = insertNodeInTree(node.right, value);
            }
            // If value equals node.data, don't insert (no duplicates)

            return node;
        }

        function deleteNodeFromTree(node, value) {
            if (!node) return null;

            if (value < node.data) {
                node.left = deleteNodeFromTree(node.left, value);
            } else if (value > node.data) {
                node.right = deleteNodeFromTree(node.right, value);
            } else {
                // Node to be deleted found
                if (!node.left) return node.right;
                if (!node.right) return node.left;

                // Node has two children
                let minRight = findMin(node.right);
                node.data = minRight.data;
                node.right = deleteNodeFromTree(node.right, minRight.data);
            }

            return node;
        }

        function findMin(node) {
            while (node.left) {
                node = node.left;
            }
            return node;
        }

        function rebuildTreeVisualization() {
            // Clear existing visualization
            const container = document.getElementById('treeVisualization');
            container.innerHTML = '';

            // Create new SVG and nodes based on current tree structure
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'tree-svg');
            svg.setAttribute('viewBox', '0 0 800 400');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            // Draw tree recursively
            const positions = {};
            calculatePositions(treeData, 400, 55, 150, positions, 1);
            drawConnections(treeData, svg, positions);
            drawNodes(treeData, container, positions);

            container.appendChild(svg);
        }

        function calculatePositions(node, x, y, spacing, positions, id) {
            if (!node) return id;

            positions[node.data] = { x, y, id: `node-${id}` };

            let nextId = id + 1;
            if (node.left) {
                nextId = calculatePositions(node.left, x - spacing, y + 100, spacing * 0.6, positions, nextId);
            }
            if (node.right) {
                nextId = calculatePositions(node.right, x + spacing, y + 100, spacing * 0.6, positions, nextId);
            }

            return nextId;
        }

        function drawConnections(node, svg, positions) {
            if (!node) return;

            const pos = positions[node.data];

            if (node.left) {
                const leftPos = positions[node.left.data];
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', pos.x);
                line.setAttribute('y1', pos.y);
                line.setAttribute('x2', leftPos.x);
                line.setAttribute('y2', leftPos.y);
                line.setAttribute('stroke', '#333');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);

                drawConnections(node.left, svg, positions);
            }

            if (node.right) {
                const rightPos = positions[node.right.data];
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', pos.x);
                line.setAttribute('y1', pos.y);
                line.setAttribute('x2', rightPos.x);
                line.setAttribute('y2', rightPos.y);
                line.setAttribute('stroke', '#333');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);

                drawConnections(node.right, svg, positions);
            }
        }

        function drawNodes(node, container, positions) {
            if (!node) return;

            const pos = positions[node.data];
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tree-node';
            nodeDiv.id = pos.id;
            nodeDiv.setAttribute('data-value', node.data);
            nodeDiv.style.top = `${pos.y - 25}px`;
            nodeDiv.style.left = `${pos.x - 25}px`;
            nodeDiv.textContent = node.data;

            container.appendChild(nodeDiv);

            if (node.left) drawNodes(node.left, container, positions);
            if (node.right) drawNodes(node.right, container, positions);
        }

        function resetTree() {
            // Clear all highlights and visited states
            const allNodes = document.querySelectorAll('.tree-node');
            allNodes.forEach(node => {
                node.classList.remove('highlight', 'visited');
            });

            currentTraversal = [];
            isTraversing = false;

            // Remove any existing traversal sequence display
            const existingSequence = document.querySelector('.traversal-sequence');
            if (existingSequence) {
                existingSequence.remove();
            }

            showResult("Tree reset. Ready for new traversal.", "info");
        }

        function displayTraversalSequence(traversalType, sequence) {
            // Remove any existing sequence display
            const existingSequence = document.querySelector('.traversal-sequence');
            if (existingSequence) {
                existingSequence.remove();
            }

            // Create new sequence display
            const sequenceDiv = document.createElement('div');
            sequenceDiv.className = 'traversal-sequence';
            sequenceDiv.innerHTML = `<strong>${traversalType} Sequence:</strong> ${sequence.join(' → ')}`;

            // Insert after result display
            const resultDisplay = document.getElementById('resultDisplay');
            resultDisplay.parentNode.insertBefore(sequenceDiv, resultDisplay.nextSibling);
        }

        function showResult(message, type = "info") {
            const resultDiv = document.getElementById('resultDisplay');
            resultDiv.textContent = message;

            // Remove all type classes
            resultDiv.classList.remove('success', 'error', 'info');

            // Add the appropriate type class
            if (type) {
                resultDiv.classList.add(type);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Prevent multiple traversals from running simultaneously
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && isTraversing) {
                resetTree();
            }
        });

        /*
            EDUCATIONAL NOTE: Dynamic Tree Line Calculation

            The function below dynamically calculates the position and rotation
            of the lines connecting the tree nodes. This ensures that the
            visualization remains correct even when the window is resized.

            It works by:
            1. Getting the coordinates of the parent and child nodes.
            2. Calculating the distance (length) and angle (rotation) between them.
            3. Applying these calculations to the line's CSS properties.
        */
        function updateTreeLines() {
            const connections = [
                { from: 1, to: 2 }, { from: 1, to: 3 },
                { from: 2, to: 4 }, { from: 2, to: 5 },
                { from: 3, to: 6 }, { from: 3, to: 7 }
            ];

            connections.forEach(conn => {
                const parentEl = document.getElementById(`node-${conn.from}`);
                const childEl = document.getElementById(`node-${conn.to}`);
                const lineEl = document.getElementById(`line-${conn.from}-to-${conn.to}`);

                if (parentEl && childEl && lineEl) {
                    drawConnection(parentEl, childEl, lineEl);
                }
            });
        }

        function drawConnection(parentEl, childEl, lineEl) {
            const parentRect = parentEl.getBoundingClientRect();
            const childRect = childEl.getBoundingClientRect();
            const containerRect = document.getElementById('treeVisualization').getBoundingClientRect();

            // Calculate coordinates relative to the container
            const parentX = parentRect.left + parentRect.width / 2 - containerRect.left;
            const parentY = parentRect.top + parentRect.height / 2 - containerRect.top;
            const childX = childRect.left + childRect.width / 2 - containerRect.left;
            const childY = childRect.top + childRect.height / 2 - containerRect.top;

            // Calculate distance and angle
            const deltaX = childX - parentX;
            const deltaY = childY - parentY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

            // Apply styles to the line element
            lineEl.style.width = `${distance}px`;
            lineEl.style.transform = `rotate(${angle}deg)`;
            lineEl.style.top = `${parentY}px`;
            lineEl.style.left = `${parentX}px`;
        }
    </script>
</body>

</html>